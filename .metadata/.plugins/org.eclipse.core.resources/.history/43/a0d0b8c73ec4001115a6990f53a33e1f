//Jan Philipp Bamberger, Ewald Bayer, Stephan Malzkorn, Leon Peulings
package Aufgabe_23;

public class Graphen {
	private double[][] am;

	public Graphen(int n){
		am = new double[n][n];
		for (int i = 0; i < am.length; i++) {
			for (int j = 0; j < am[i].length; j++) {
				am[i][j] = 0;
			}
		}
	}

	public void setEdge(int id1, int id2, double value){
		if ((id1 < am.length && id1 >= 0)&&(id2 < am[id1].length && id2 >= 0)) {
			if (value < 1) {
				am[id1][id2] = 0;
				am[id2][id1] = 0;
			} else if(value >=1){
				am[id1][id2] = 1;
				am[id2][id1] = 1;
			}// TODO Ansehen (Da wir das gestern im Tutorium hatten, habe ich die auskommentierte Symmetrie wieder eingebunden.)
			//Jan Philipp: Sieht so gut aus.
		}
	}

	public String toString(){
		//TODO fï¿½r Leon: Dem Vorgehen hier zustimmen und die Kommentare entfernen.
		//		String temp = "";
		//		for (int i = 0; i < am.length; i++) {
		//			for (int j = 0; j < am[i].length; j++) {
		//				temp += "Value at: " + i + "/" + j + "=" + am[i][j] + "\n";
		//			}
		//		}
		//		return temp;

		//nichtmehrTODO Denkt mal darï¿½ber nach, ob das vielleicht besser wï¿½re (Jan Philipp: Meiner Meinung nach besser)
		String temp = "";
		for (int i = 0; i < am.length; i++) {
			for (int j = 0; j < am[i].length; j++) {
				temp += am[i][j] + "\t";
			}
			temp += "\n";
		}
		return temp;
	}
	public Graphen generateTransitiveClosure(){
		Graphen temp = new Graphen(am.length);
		for (int i = 0; i < temp.am.length; i++) {
			temp.am[i] = am[i].clone();
		}
		// TODO ï¿½berprï¿½fen - Ich bin davon ausgegangen, Leon hï¿½tte hier sonst alles richtig gemacht.
		for (int k = 0; k < am.length; k++) {
			for (int i = 0; i < am.length; i++) {
				if (am[i][k] == 1) {
					for (int j = 0; j < am.length; j++) {
						if (am[k][j] == 1) {
							temp.setEdge(i, j, 1);
							temp.setEdge(j, i, 1);
						}
					}
				}
			}
		}
		return temp;
	}
	//	public String doDepthFirstSearch(){
	//		//TODO Kein Plan, Leute. :D
	//		//Jan Philipp: Mir wÃ¼rde nur eine rekursive LÃ¶sung einfallen.
	//		int startknoten = (int)(Math.random()*am.length);
	//		int next = (startknoten+1)%am.length;
	//		int rueck = 0;
	//		while(next != startknoten){
	//			rueck += am[startknoten][next]==1?doDepthFirstSearch(next, startknoten):1;
	//			next = (next+1)%am.length;
	//		}		
	//		return "Die Tiefe beträgt: " + rueck;
	//	}
	//	private int doDepthFirstSearch(int startelement, int wurzel){
	//		//TODO Kein Plan, Leute. :D
	//		//Jan Philipp: Mir wÃ¼rde nur eine rekursive LÃ¶sung einfallen.
	//		int next = (wurzel+1)%am.length;
	//		int rueck = 0;
	//		while(next != wurzel){
	//			rueck += am[startelement][next]==1?doDepthFirstSearch(next, startelement):1;
	//			next = (next+1)%am.length;
	//		}		
	//		return rueck;
	//	}

	public String doDepthFirstSearch(){
		//TODO Kein Plan, Leute. :D
		//Jan Philipp: Mir wÃ¼rde nur eine rekursive LÃ¶sung einfallen.
		int startknoten = (int)(Math.random()*am.length);
		int firstStartknoten = startknoten;
		int next = (startknoten+1)%am.length;
		int startknoten_bak = -1;
		int next_bak = -1;
		int max = 0;
		int newMax =0;
		do{
			newMax = 0;
			while(next != startknoten){
				if(am[startknoten][next]==1){
					newMax++;
					startknoten_bak = startknoten;
					next_bak = next;
					startknoten = next;
					next = startknoten_bak;
				}
				next = (next+1)%am.length;
			}
			if(newMax > max){
				max = newMax;
				newMax++;
			}else{
				if(startknoten_bak != -1){
					newMax = max + 1;
					startknoten = startknoten_bak;
					next = next_bak;
					startknoten_bak = -1;
					next_bak = -1;
				}
			}
		}while(max < newMax && startknoten != firstStartknoten);
		return "Die Tiefe beträgt ausgehend von " + firstStartknoten + ": " + max;
	}

	public void eliminateCycle(){
		//TODO ï¿½berprï¿½fen
		//Jan Philipp: Sollen wir auch grÃ¶ÃŸere Kreise unterbrechen? Sonstv ist die LÃ¶sung ausreichend
		for (int i = 0; i < am.length; i++) {
			if(am[i][i] > 0)
				am[i][i] = 0;
		}
	}
}
